using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;

namespace TBBProject.Core.Common
{
    /* See jhtodd/SequentialGuid https://github.com/jhtodd/SequentialGuid/blob/master/SequentialGuid/Classes/SequentialGuid.cs */
    /* See : https://www.codeproject.com/Articles/388157/GUIDs-as-fast-primary-keys-under-multiple-database */
    public class SequentialGuidGenerator : IGuidGenerator
    {
        public static SequentialGuidGenerator Instance = new SequentialGuidGenerator();

        #region Static Fields
        /// <summary>
        /// Provides cryptographically strong random data for GUID creation.
        /// </summary>
        private static readonly RNGCryptoServiceProvider RandomGenerator = new RNGCryptoServiceProvider();
        #endregion

        /// <summary>
        /// Returns a new GUID value which is sequentially ordered when formatted as
        /// a string, a byte array, or ordered by the least significant six bytes of the
        /// Data4 block.
        /// </summary>
        /// Specifies the type of sequential GUID (i.e. whether sequential as a string,
        /// as a byte array, or according to the Data4 block.  This can affect
        /// performance under various database types; see below.
        /// </param>
        /// <returns>
        /// A <see cref="Guid" /> structure whose value is created by replacing
        /// certain randomly-generated bytes with a sequential timestamp.
        /// </returns>
        /// <remarks>
        /// <para>
        /// This method creates a new GUID value which combines a random component
        /// with the current timestamp, also known as a COMB.  The general concept
        /// is outlined in Jimmy Nilsson's article "The Cost of GUIDs as Primary Keys",
        /// and involves replacing either the least significant or most significant
        /// six bytes of the GUID with the current timestamp.  This reduces the
        /// random component of the GUID from 16 bytes to 10 bytes, but this is
        /// still sufficient to prevent a collision under most real-world circumstances.
        /// </para>
        /// <para>
        /// The purpose of sequential GUIDs is not to promote the use of GUIDs as
        /// sortable entities.  In fact, GUIDs generated very close together may
        /// have the same timestamp and are not guaranteed to be sequentially ordered
        /// at all.  The intent is to increase performance when doing repeated
        /// inserts into database tables that have a clustered index on a GUID
        /// column, so that later entries do not have to be inserted into the middle
        /// of the table, but can simply be appended to the end.
        /// </para>
        /// <para>
        /// According to experiments, Microsoft SQL Server sorts GUID values using
        /// the least significant six bytes of the Data4 block; therefore, GUIDs being
        /// generated for use with SQL Server should pass a
        /// value of <c>SequentialAtEnd</c>.  GUIDs generated for most other database
        /// types should be value of
        /// <c>SequentialAsString</c> or <c>SequentialAsByteArray</c>.
        /// </para>
        /// <para>
        /// Various standards already define a time-based UUID; however, the
        /// format specified by these standards splits the timestamp into
        /// several components, limiting its usefulness as a sequential ID.
        /// Additionally, the format used for such UUIDs is not compatible
        /// with the GUID ordering on Microsoft SQL Server.
        /// </para>
        /// </remarks>
        public Guid Generate()
        {
            // We start with 16 bytes of cryptographically strong random data.
            var randomBytes = new byte[10];
            SequentialGuidGenerator.RandomGenerator.GetBytes(randomBytes);

            // An alternate method: use a normally-created GUID to get our initial
            // random data:
            // byte[] randomBytes = Guid.NewGuid().ToByteArray();
            // This is faster than using RNGCryptoServiceProvider, but I don't
            // recommend it because the .NET Framework makes no guarantee of the
            // randomness of GUID data, and future versions (or different
            // implementations like Mono) might use a different method.

            // Now we have the random basis for our GUID.  Next, we need to
            // create the six-byte block which will be our timestamp.

            // We start with the number of milliseconds that have elapsed since
            // DateTime.MinValue.  This will form the timestamp.  There's no use
            // being more specific than milliseconds, since DateTime.Now has
            // limited resolution.

            // Using millisecond resolution for our 48-bit timestamp gives us
            // about 5900 years before the timestamp overflows and cycles.
            // Hopefully this should be sufficient for most purposes. :)
            var timestamp = DateTime.UtcNow.Ticks / 10000L;

            // Then get the bytes
            var timestampBytes = BitConverter.GetBytes(timestamp);

            // Since we're converting from an Int64, we have to reverse on
            // little-endian systems.
            if (BitConverter.IsLittleEndian)
            {
                Array.Reverse(timestampBytes);
            }

            var guidBytes = new byte[16];

            Buffer.BlockCopy(randomBytes, 0, guidBytes, 0, 10);
            Buffer.BlockCopy(timestampBytes, 2, guidBytes, 10, 6);

            return new Guid(guidBytes);
        }

    }
}
